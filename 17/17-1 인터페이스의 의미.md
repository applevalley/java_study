# 17-1 인터페이스의 의미

> 상속과 비슷하면서도 다른 구현의 세계

- 인터페이스란?

  - 클래스들이 구현해야 하는 동작을 지정하는 데 주로 사용하는 자료형
  - class가 아닌 `interface`선언이 붙어 있다.
  - 다음과 같이 생겼다!

  ```java
  interface abc {
      public void printIt(String str);  // 요것이 추상 메서드
  }
  ```

  - 추상 메서드?
    - 위와 같이 메서드의 바디가 비어 있는 메서드를 가리켜 **추상 메서드**라고 한다!
    - 바디 없이 세미콜론을 통해 마무리된다.



- 인스턴스 생성은 불가능하지만..

  - 인터페이스를 대상으로는 인스턴스를 생성할 수 없다!
  - 이는 객체로 생성될 수 없다는 의미이고, 생성자 또한 가질 수 없다는 것을 의미한다.
  - 인스턴스는 생성할 수 없지만, 인터페이스의 타입을 대상으로 참조변수의 선언은 가능하다!
    - 참조변수를 대상으로 인터페이스에 정의된 추상 메서드를 호출할 수 있다.
    - 이 경우 실제로는 오버라이딩으로 인해 인터페이스의 메서드가 아닌 구현한 클래스의 메서드가 호출!

  

- 인터페이스에 대한 정보

  - 클래스가 인터페이스를 상속하는 것은 상속이 아닌 **구현**!

  - 문법 구조는 상속과 같지만, 구현하는 것에 더 가깝다.

  - 구현하고자 하는 인터페이스를 명시할 때에는 `implements` 키워드를 사용한다!

  - 한 클래스는 둘 이상의 인터페이스를 동시에 구현하는 것이 가능하다.

  - 상속과 구현은 동시에 가능하다.

    - `class Soccer extends Hobby implements indoor, outdoor {...} `

  - 인터페이스의 추상 메서드와 이를 구현하는 메서드 간에는 오버라이딩 관계가 성립한다.

    

  ```java
  // Printable.java
  
  interface Eatable {
  	public void eat(String food);
  }
  
  // 햄버거 클래스가 Eatable 인터페이스를 구현하고 있다!
  // 구현에 대한 선언은 implements를 이용한다.
  // s가 붙은 것에서 알 수 있듯 여러 인터페이스를 동시에 구현할 수 있다.
  class Hamburger implements Eatable {
  	@Override
      // 인터페이스의 추상 메서드에는 바디가 없다.
      // 엄격하게 따지고 보면 오버라이딩 관계라고 하긴 어렵지만,
      // 메서드의 호출 관계에서는 오버라이딩 관계가 성립된다!
      // 따라서 @Override 어노테이션을 붙이는 데에도 문제가 없다.
  	public void eat(String food) {   
  		System.out.println(food);
  	}
  }
  
  public class Printable {
  
  	public static void main(String[] args) {
  		// Eatable 인터페이스를 직/간접 구현하는 클래스의 인스턴스를 Eatable형 참조변수가 참조
  		Eatable ham = new Hamburger();
  		ham.eat("Let's eat Hamburger"); 
  	}
  }
  ```

  