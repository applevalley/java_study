# 10-1 static 선언을 붙여 선언하는 클래스 변수

> 인스턴스를 만들지 않더라도 괜찮아!

- 인스턴스 변수란?

  - 인스턴스가 생성되었을 때 생성된 인스턴스 안에 존재하는 변수다!

  - 당연하게도 인스턴스가 생성되지 않는다면, 존재할 수 없다.



- 그러면 클래스 변수는?
  - 인스턴스의 생성과는 전혀 무관하게 존재하는 변수다!
  - static으로 선언된 클래스 변수는 변수가 선언되어 있는 클래스의 모든 인스턴스가 공유한다!



- 어떻게 다를까?

  ```java
  // ClassVariable.java
  
  class IncNum {
  	static int increNum = 0; // 클래스 변수 선언! 해당 클래스의 모든 인스턴스가 공유하는 변수
  	
  	IncNum() {
  		increNum++;
  		System.out.println("value: " + increNum);
  	}
  }
  
  class ConNum {
  	int conNum = 0;  // 인스턴스 변수 선언! 다른 인스턴스와는 공유하지 않는다.
  	
  	ConNum() {
  		conNum++;
  		System.out.println("value: " + conNum);
  	}
  }
  
  public class ClassVariable {
  
  	public static void main(String[] args) {
  
  		IncNum inc1 = new IncNum(); 
  		IncNum inc2 = new IncNum();
  		IncNum inc3 = new IncNum();
  		
  		System.out.println();
  		
  		ConNum con1 = new ConNum();
  		ConNum con2 = new ConNum();
  		ConNum con3 = new ConNum();
  	}
  
  }
  ```

  - 수행 결과는?

  ```java
  value: 1 // 클래스 변수! 모든 인스턴스가 공유한다.
  value: 2 // 따라서 인스턴스가 생성될 때마다 생성자 increNum()에 의해 변수의 값이 증가한다.
  value: 3
  
  value: 1 // 인스턴스 변수!
  value: 1 // 각 인스턴스마다 별개의 변수이다. 
  value: 1
  ```

  

- 클래스 변수에 접근하려면?

  - 내부에서 변수명으로 접근하거나, 외부에서 클래스명, 인스턴스명으로 접근하거나

  ```java
  // ClassVariableAccess.java
  
  class WayToAccess {
  	static int num = 0;
  	
  	WayToAccess() {
  		increaseNum();
  	}
  	
  	void increaseNum() {
  		num++;                                   // 변수명을 통한 클래스 내부 접근
  	}
  }
  
  public class ClassVariableAccess {
  
  	public static void main(String[] args) {
  
  		WayToAccess access = new WayToAccess();  // 참조변수 access가 생성되었다!
  		System.out.println(WayToAccess.num);     
  		access.num++;                            // 인스턴스명을 통한 클래스 외부 접근
  		System.out.println(WayToAccess.num);     
  		WayToAccess.num++;                       // 클래스명을 통한 클래스 외부 접근
  		System.out.println(WayToAccess.num);     
  		System.out.println("num = " + WayToAccess.num); 
  	}
  
  }
  ```

  - 외부에서 접근하는 경우, 인스턴스명보다는 클래스명을 통해 접근하는 것이 더 알기 편하다!
  - 접근 제어 지시자가 설정되지 않았기에(default) 같은 패키지로 묶여있다면 접근이 가능!
  - 위에서는 디폴트 패키지로 묶여 있기에 접근이 가능하다.



- 클래스 변수는 언제 초기화할까? 어떻게 초기화할까?

  - 클래스 변수는 언제 메모리에 할당되고 초기화되는걸까?

  ```java
  // ClassWithoutInstance.java
  
  class NoInstance {
      // 만약 정보 은닉을 이유로 앞에 접근 제어 지시자로 private를 선언한다면?
      // 아래의 클래스에서 접근을 못 한다..
  	static int num = 50; // 클래스 변수 num
  	
  	NoInstance() {
  		num++;
  		System.out.println("instance created: " + num);
  	}
  }
  
  public class ClassWithoutInstance {
  
  	public static void main(String[] args) {
  
  		// 인스턴스의 생성 없이 클래스 변수 num에 접근했다.
          // 인스턴스가 생성되지 않았기에, 생성자 NoInstance도 동작하지 않았다!
  		// 따라서 연산의 결과는 40이다. 41이 아니다!
  		NoInstance.num -= 10;
  		System.out.println(NoInstance.num);
  		
  		// 아래와 같이 참조 변수 no1이 인스턴스의 주소 값을 참조하게 한다면?
  		// 인스턴스가 생성되었기에, 생성자도 동작한다!
  		// 이제 num의 최종 값은 41이 된다.
  //		NoInstance no1 = new NoInstance();
  	}
  
  }
  ```

  - 위의 예시가 말하는 것은?
    - **클래스 변수는 인스턴스의 생성 이전에 메모리에 할당된다**는 것이다.
    - JVM이 해당 클래스의 정보를 읽는 순간, 메모리 공간에 할당되고 초기화된다.
    - 이는 인스턴스의 생성과 무관하다! 클래스 변수에 직접 접근해 연산했던 것이 이를 뒷받침한다.
      - 만약 생성자에서 클래스 변수에 값을 할당한다면, 변수가 새로 초기화되어버린다!
      - 인스턴스가 생성될 때마다 의도치 않게 변수의 값이 바뀌어버리게 된다.

  

- 클래스 변수는 언제 유용하게 쓰일까?

  - **인스턴스 간 데이터의 공유가 필요할 때** 클래스 변수를 선언하자!

  ```java
  // UtilizeClassVariable.java
  
  class House {
  	static final int price = 10000;
  	private int size;
  	
  	House(int si) {
  		size = si;
  	}
  	
  	void price() {
  		int fullprice = (size * price);
  		System.out.println("size x price = " + fullprice);
  	}
  	
  }
  
  public class UtilizeClassVariable {
  
  	public static void main(String[] args) {
  
  		House ho = new House(30);
  		ho.price();
  	}
  
  }
  ```

  - final 선언을 통해 클래스 변수 price를 상수로 만들 수 있다!
    - price는 변하지 않는 값
    - 모든 인스턴스가 참조하지만 개별 인스턴스가 전부 가져야 하는 값은 아닌 경우

  - 참조를 목적으로만 존재하는 값일 때 final 선언이 된 클래스 변수에 담아주기
  - 외부에서 접근해도 문제가 되지 않을 변수라면 public 선언을 해 줘도 좋다