# 13-1 1차원 배열

> 배열도 인스턴스야!!!!

- 배열?
  - `같은 타입을 가지는 둘 이상의 데이터를 담을 수 있는 n차원 구조의 메모리 공간`



- 속닥속닥.. 배열도 인스턴스래...

  - 자바는 배열도 인스턴스로 처리한다!

  ```java
  // ArrayInstance.java
  
  class EmptyBox {
  	private String words;
  	
  	EmptyBox(String str) {
  		this.words = str;
  	}
  	
  	public String toString() {
  		return words;
  	}
  }
  
  public class ArrayInstance {
  
  	public static void main(String[] args) {
  		
          // 길이가 10인 int형 1차원 배열의 생성문
          // int형 변수 10개가 묶인 것이 메모리 공간에 올라가고, arr1이 그것을 참조하게 된다.
  		int[] arr1 = new int[10];  // int[] arr1 -> int형 배열을 참조하는 참조 변수 arr1
  		String[] arr2 = new String[20];
  		
  		System.out.println(arr1.length); // 배열의 인스턴스 변수에 접근
  		System.out.println(arr2.length);
  		
  		EmptyBox[] arr3 = new EmptyBox[30]; // 길이가 30인 EmptyBox형 1차원 배열의 생성
  		System.out.println(arr3.length);
          
          arr3[0] = new EmptyBox("Hello");    // 배열에 인스턴스를 저장!
  		System.out.println(arr3[0].toString()); // 0번 외의 값은 전부 null로 채워져있다.
          
          arr1[0] = 3;        // 배열 arr1의 첫 요소에 3이라는 정수 값을 저장
  		System.out.println(arr1[0]);
  	}
  
  }
  ```
  
  - `int[] ref = new int[10]`
    - int[] ref: int형 1차원 배열 인스턴스를 참조하는 참조변수 선언
      - int[]: 참조할 대상에 대한 자료형 정보
    - new int[10]: int형 값 10개를 저장할 수 있는 배열 인스턴스 선언
    - 두 줄로 나눠서 해도 된다.
      - int[] ref;
      - ref = new int[10];
  
  
  
  - 원시 자료형을 대상으로 만들수도 있고, 인스턴스를 저장할 수 있는 배열의 생성도 가능하다.
    - 1차원 배열의 참조변수는 배열의 길이와는 무관하게 참조가 가능하다!
    - 이 경우 인스턴스 변수인 length 등에 접근이 가능하다.
    - 주의할 것
      - 인스턴스의 생성과는 무관하다!
      - `EmptyBox[] arr3 = new EmptyBox[30];`과 같은 문장을 통해 30개의 인스턴스를 저장할 수 있는 배열이 생성되는 것이지 인스턴스 30개까지 자동으로 생겨나는게 아니다.



- 배열에 값을 저장하고, 참조해보자

  - 값의 저장

    - `int[] arr1 = new int[3];`

    - `arr1[0] = 3;`  이렇게 값을 저장할 수 있다.

    - 인스턴스를 저장할 수 있는 배열의 경우에도 `EmptyBox[0] = new Emptybox("Hi");` 처럼 저장!

    - 직접 하나씩 넣어도 되지만..

      - 반복문이라면?

      ```java
      // ArrayInstance.java
      
      EmptyBox[] arr3 = new EmptyBox[10];
      
      for (int i=1; i < arr3.length; i++) {  // for loop로 인스턴스 저장하기
          arr3[i] = new EmptyBox("Yes");
      }
      
      System.out.println();
      
      for (int i=0; i < arr3.length; i++) {  // 모든 인스턴스들을 순회하며 출력할 수 있다.
          System.out.println(arr3[i]);
      }
      ```

      

  - 값의 참조

    - 인덱스 값을 이용해 참조할 수 있다.
    - `System.out.println(EmptyBox[0]);`



- 배열도 변수처럼 생성과 동시에 초기화할 수는 없을까?
  - 왜 안되겠어
    - 보통은 이렇게 생성한다... `double[] arr = new double[2]`
    - 생성과 동시에 초기화하려면, 뒤에 중괄호를 이용해 초기화할 값들을 넣어준다.
    - `double[] arr = new double[2] {2.0, 3.1};`
    - 하지만 이 경우 `double[2]`에 해당하는 숫자 부분을 지워주어야 한다!
    - 그리고 `{2.0, 3.1};` 만 봐도 이 배열을 생성하고 double형 데이터로 초기화하려는 것을 알 수 있다.
    - 따라서 `double[] arr = {2.0, 3.1};`  이렇게 줄여서도 쓸 수가 있다!!
    - 길이가 2인 double형 배열이 생성되고, 값이 채워져 초기화된 뒤 반환되는 참조 값을 참조 변수 arr이 참조하게 된다.



- 참조변수의 선언은 어디에서나
  -  참조변수의 선언이 매개변수 자리에도 올 수 있다!

    - 이 경우 배열의 참조 값이 메서드의 전달 인자로 오게 된다.

    ```java
    // ArrayInstance.java
    
    // 배열이 새로 생성되는게 아니다!!!
    // int형 데이터 3개를 담고 있는 배열 인스턴스(참조변수 int4가 참조하는)의 참조 값이 메서드의 인자로 전해졌다.
    // 따라서 새 배열이 생기는게 아니라, 메서드 안에서도 기존 배열 인스턴스에 접근이 가능한 것
    static int sumArray(int[] arr) { 
        int sum = 0;                 
        for (int i=0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }	
    
    int[] arr4 = {1,2,3};
    int temp = sumArray(arr4);
    System.out.println(temp);  // 
    ```

  -  배열의 참조 값을 반환하는 메서드

    ```java
    // ArrayInstance.java
    
    static int[] makeNewArray(int num) {
        int[] arr = new int[num];
        return arr;
    }
    
    // 4개의 int형 데이터를 가지는 배열 인스턴스가 만들어지고, 참조 변수 arr5는 해당 배열 인스턴스의 참조 값을 참조한다.
    int[] arr5 = makeNewArray(4); 
    arr5[0] = 5;
    System.out.println(arr5[0]);  // 5
    ```

    
