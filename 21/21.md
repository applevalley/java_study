# 21-1 제네릭?

> 자료형에 종속적이지 않게 일반화한 클래스를 만들자!

- 제네릭 이전에는..?

  - 탕수육을 담는 상자를 만들고, 그 안에 탕수육을 담았다가 꺼내보자

  ```java
  // BeforeGeneric.java
  
  class Tangsu {
  	public String toString() {
  		return "price is 18,000 won";
  	}
  }
  
  class TangsuBox {  // 탕수육 상자
  	private Tangsu ts;
  	
  	public Tangsu getTangsu() { // 상자에서 꺼낸다
  		return ts;
  	}
  	
  	public void setTangsu(Tangsu ts) { // 상자에 담는다
  		this.ts = ts;
  	}
  	 
  }
  
  public class BeforeGeneric {
  
  	public static void main(String[] args) {
  
  		TangsuBox tang = new TangsuBox();       // 새로운 상자 생성
  		tang.setTangsu(new Tangsu());           // 상자 안에 새 탕수육 인스턴스를 넣는다
  		Tangsu ts = tang.getTangsu();           // 상자에서 꺼낸다
  		System.out.println(ts);
  	}
  
  }
  ```

  - 위처럼 하면, 만약 탕수육이 여러 종류 있다거나 다른 메뉴들이 있다거나 하면 그 메뉴에 대한 각각의 박스가 필요해진다. 다만 그 박스들은 하는 일도, 목적도 모두 같다.
  - 그렇다면 박스를 모든지 담을 수 있게 하면 어떨까..?

  ```java
  // BeforeGeneric.java
  
  class Tangsu {
  	public String toString() {
  		return "price is 18,000 won";
  	}
  }
  
  class Box {                 // 모든지 들어왔다 꺼낼 수 있는 상자
  	private Object obj;
  	
  	public Object getThing() {
  		return obj;
  	}
  	
  	public void setThing(Object obj) {
  		this.obj = obj;
  	}
  }
  
  public class BeforeGeneric {
  
  	public static void main(String[] args) {
  
  		Box tbox = new Box();           // 상자 만들기
  		tbox.setThing(new Tangsu());    // 상자 안에 탕수육 인스턴스 넣기
  		Tangsu ts2 = (Tangsu)tbox.getThing();  // 상자에서 꺼내기
  		System.out.println(ts2);
  	}
  
  }
  
  ```

  - 한결 간편해졌다! 다만 꺼내오는 과정에서 형 변환이 필요하다. 왜일까?
    - 박스 안에는 Object형 인스턴스가 들어가기 때문이다!
    - 따라서 꺼낼 때에는 인스턴스에 맞게 형 변환을 해줘야 한다.
      - setter에서 탕수육을 넣지만 getter 메서드는 Object형을 반환하기 때문에 명시적인 형 변환이 필수다!
    - 형 변환을 해주지 않는 경우 예외가 발생할 수도 있다.
      - 심지어 인스턴스가 아닌 문자열을 상자에 담는 경우 형 변환을 하지 않으면 출력 시 그냥 문자열 자체가 나온다!! 이 때는 컴파일 오류도, 예외도 안 생긴다. 큰 문제다.
    - 이처럼 형 변환을 요하고, 프로그래머가 실수를 해도 오류나 예외가 나지 않을 수 있다는 문제가 있다.



- 제네릭 기반으로 클래스를 정의해보자

  - 제네릭을 통해 자료형에 의존하지 않는 클래스를 정의할 수 있다!

    - 박스를 고쳐보자

    ```java
    // AfterGeneric.java
    
    class Box2 {  // 이 클래스는 Object형 인스턴스를 저장, 반환한다.
    	private T obj;  // 자료형에 종속적이지 않기 위해 Object를 T로 대체한다!
    	
    	public T getThing() {
    		return obj;
    	}
    	
    	public void setThing(T obj) {  // T는 인스턴스를 생성할 때 결정함
    		this.obj = obj;           // 인스턴스 생성 시 T의 자료형을 결정하는 것이 제네릭!
    	}
    }
    ```

    - 엥 컴파일 에러가 나는데요?

      - 위처럼 하면 컴파일러가 `T`를 클래스 이름으로 인식하고 T라는 클래스가 없다는 오류를 알린다!
      - 따라서 T는 **클래스의 이름**이 아니라, **인스턴스 생성 시 자료형을 결정하는 기준**이 되어야 한다.
      - T가 아니라 `<T>`처럼 하면 된다!

      ```java
      class Box2<T> { ... }   // 요렇게
      ```

      

  - 종합해보면..?

    ```java
    // AfterGeneric.java
    
    class Tangsu2 {
    	public String toString() {
    		return "price is 18,000 won";
    	}
    }
    
    class Box2<T> {
    	private T obj;
    	
    	public T getThing() {
    		return obj;
    	}
    	
    	public void setThing(T obj) {
    		this.obj = obj;
    	}
    }
    
    public class AfterGeneric {
    
    	public static void main(String[] args) {
    	
    	    // T를 Tangsu2로 결정해 인스턴스를 만들었다.
    	    // 이제 Tangsu2나 Tangsu2를 상속하는 클래스들의 인스턴스를 저장할 수 있다!
    	    // Box2<T>에서 사용된 T를 타입 매개변수라고 한다.
    	    // Box2<Tangsu2>에서의 Tangsu2는 타입 인자라고 한다.
    	    // Box2<Tangsu2>를 통째로 가리켜 매개변수화 타입 또는 제네릭 타입이라고도 부른다!
    	    // 자료형 Tangsu2가 타입 매개변수 T에 전달되어 Box2<Tangsu2>라는 새 자료형이 완성되었기 때문
    		Box2<Tangsu2> tang = new Box2<Tangsu2>(); // 여기서 <T>가 정해짐으로 인해
    		tang.setThing(new Tangsu2());
    		Tangsu2 ts2 = tang.getThing(); // getter의 반환형도 결정되고, 형 변환 안해도 된다
    		System.out.println(ts2);
    	}
    
    }
    ```
    
    - 이제 형 변환을 필수로 해야 하거나, 실수를 걱정하지 않아도 된다!
  
  

