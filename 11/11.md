# 11-1 메서드 오버로딩

> 매개변수로 구분해보자!

- 보통 클래스에서 같은 이름의 메서드들을 정의하면 안 된다

  - 하지만 매개변수의 선언이 다르다면 가능하고, 이를 **클래스 오버로딩**이라고 한다!

  - 보통 JVM은 호출할 메서드를 찾을 때 2가지를 확인한다.
    - 메서드의 이름
    - 메서드의 매개변수
  - 메서드간 이름이 다르다면, 호출할 때 구분이 가능하다.
  - 이름이 같더라도 각 메서드가 다른 매개변수를 가진다면, 서로 다른 메서드로 간주된다.
    - 매개변수의 수나 타입이 다른 경우가 해당
  - 반환형이 다르면 오버로딩이 안 된다! 메서드 호출의 기준은 반환형이 아니기 때문이다. 

  ```java
  // OverloadingWithAnotherParameter.java
  
  class Number {
  	
      // myNumber라는 같은 이름의 메서드들이 있지만 매개변수들이 다르다!
  	void myNumber(int n) {
  		System.out.println(n);
  	}
  	
  	void myNumber(int n1, int n2) {
  		System.out.println(n1 + "\t" + n2);
  	}
  	
  	void myNumber(double n1, double n2) {
  		System.out.println(n1 + "\t" + n2);
  	}
  	
  	int printNumber() {
  		return 1;
  	}
  	
  	// 같은 이름이어도 반환형이 다르다면, 오류가 난다! 
  //	double printNumber() {
  //		return 0.1;
  //	}
  }
  
  public class OverloadingWithAnotherParameter {
  
  	public static void main(String[] args) {
  
  		Number num = new Number();
  		num.myNumber(1);
  		num.myNumber(4, 5);
  		num.myNumber(0, ',');
  		num.myNumber(0.24, 0.12);
  		
  		int x = num.printNumber();
  		System.out.println(x);
  	}
  
  }
  ```

  - 주의할 점

    - 메서드에 인자를 전달할 때 형 변환이 일어나게 하지 말자!

    ```java
    class Test {
        void sample(int a, int b) {
            ..
        }
        void sample(int a, double b){
            ..
        }
    }
    
    ...
        Test xxx = new Test();
    	xxx.sample(20, 'A'); // 야생의 char가 튀어나왔다!
    ```
    
    - 물론, 형 변환 규칙에 의거해 char는 int나 double로 형 변환이 될 것이다.
    - 형 변환을 할 때 char와 int의 거리가 char와 double의 거리보다 가깝기 때문에, int로 형 변환된다.
    - 그렇지만 꼭 이렇게 써야 할까?
    - 자동 형 변환을 활용하려고 하기보다 이런 경우를 만들지 않는게 바람직하다.
    - 만약 이러한 인자를 전달해야 한다면, 인자 앞에 명시적으로 형 변환을 해주자.
    
    

- 생성자도 오버로딩할 수 있어
  - 생성자 역시 다른 매개변수를 가진다면, 둘 이상 쓸 수 있다.
  - 생성자 오버로딩을 통해 생성되는 인스턴스의 유형을 구분할 수 있다!!
  
  ```java
  // OverloadingWithConstructor.java
  
  class NewEmployee {
  	private String team;        // 어떤 신입사원은 사원번호가 없을 수도 있다
  	private String name;
  	private int empNum;
  	
  	// 매개변수가 다르다면 생성자 오버로딩도 오케이
  	NewEmployee(String tname, String ename, int number) {
  		team = tname;
  		name = ename;
  		empNum = number;
  	}
  	
  	NewEmployee(String tname, String ename) {
  		team = tname;
  		name = ename;
  		empNum = 0;
  	}
  	
  	void introduceNewEmployee() {
  		System.out.println("team: " + team);
  		System.out.println("name: " + name);
  		
  		if (empNum == 0) {
  			System.out.println("employeeNum is not found." + "\n");
  		}
  		else {
  			System.out.println("his employeeNum is: " + empNum + "\n");
  		}
  	}
  }
  
  public class OverloadingWithConstructor {
  
  	public static void main(String[] args) {
  
  		NewEmployee kim = new NewEmployee("Dev", "Dave Kim", 123213);
  		NewEmployee lee = new NewEmployee("HR", "Susan Lee"); // 사원번호가 없는 사원
  		
  		kim.introduceNewEmployee();
  		lee.introduceNewEmployee();
  	}
  
  }
  ```
  
  

   - this?

        - 키워드 this를 이용한 생성자 호출

             - 오버로딩된 다른 생성자!
             - 인자를 전달받아서, 해당 인자를 매개변수로 가지는 다른 생성자에 전달한다.
             - 아래의 경우 this("undefined", ename);을 통해 tname과 ename을 매개변수로 가지는 생성자에 인자를 넘겨준다.
             - 키워드 this가 포함된 생성자는 인스턴스 변수를 초기화할 값만 전달해주는 것!
             - 실제 초기화는 인자를 전달받은 생성자가 수행하게 된다.
             - 이러한 과정을 통해 다양한 인스턴스를 정의하고, 변수를 초기화하는 과정에서 코드를 많이 줄일 수 있다!

          ```java
          // OverloadingWithConstructor.java
          
          class NewEmployee {
          	private String team;
          	private String name;
          	private int empNum;
          	
          	...
          	
          	NewEmployee(String tname, String ename) {
          		team = tname;
          		name = ename;
          		empNum = 0;
          	}
          	
          	NewEmployee(String ename) {
          		this("undefined", ename); // undefined와 ename을 인자로 받는 생성자 호출!
          	}
          	
          	void introduceNewEmployee() {
          		System.out.println("team: " + team);
          		System.out.println("name: " + name);
          		
          		if (empNum == 0) {
          			System.out.println("employeeNum is not found." + "\n");
          		}
          		else {
          			System.out.println("his employeeNum is: " + empNum + "\n");
          		}
          	}
          }
          
          public class OverloadingWithConstructor {
          
          	public static void main(String[] args) {
          
          		...
          		
          		NewEmployee park = new NewEmployee("John Park");
          		park.introduceNewEmployee();
          	}
          
          }
          ```

          
