# 16-1 상속이 도움이 될 때

> 일련의 클래스에 공통적인 규약을 적용!

- 상속 기반의 문제 해결

  - 일련의 클래스에 공통적인 규약을 적용한다는 상속의 의미를 이제 이해할 수 있게 되었다!
  - 예시를 보자

  ```java
  // Friendship.java
  
  class RealFriend {
  	private String name;
  	private String major;
  	private String telNum;
  	
  	RealFriend() {}
  	
  	RealFriend(String name, String major, String telNum) {
  		this.name = name;
  		this.major = major;
  		this.telNum = telNum;
  	}
  	
  	public void showInfo() {
  		System.out.println("이름: " + name + " 전공: " + major + " 번호: " + telNum);
  	}
  }
  
  class FakeFriend {
  	private String name;
  	private String part;
  	private String telNum;
  	
  	FakeFriend() {}
  	
  	FakeFriend(String name, String part, String telNum) {
  		this.name = name;
  		this.part = part;
  		this.telNum = telNum;
  	}
  	
  	public void showInfo() {
  		System.out.println("이름: " + name + " 전공: " + part + " 번호: " + telNum);
  	}
  }
  
  public class Friendship {
  
  	public static void main(String[] args) {
  		
  		RealFriend[] ref = new RealFriend[3];
  		FakeFriend[] faf = new FakeFriend[3];
  		
  		int reNum = 0;
  		int faNum = 0;
  		
  		ref[reNum++] = new RealFriend("김철수", "경영학과", "010-0000-0000");
  		ref[reNum++] = new RealFriend("김영희", "간호학과", "010-1111-1111");
  		
  		faf[faNum++] = new FakeFriend("박영철", "개발 1팀", "010-2222-2222");
  		faf[faNum++] = new FakeFriend("오영택", "인사과", "010-3333-3333");
  		
  		for(int i = 0; i < reNum; i++) {
  			ref[i].showInfo();
  		}
  		
  		System.out.println();
  		
  		for(int i = 0; i < faNum; i++) {
  			faf[i].showInfo();
  		}
  	}
  
  }
  ```

  - 배열이 2개이기에, 무슨 일을 하건 그 과정을 2번 해야 한다!
    - 검색을 하거나, 특정 메서드를 호출하거나 등..
  - 간단한 예시이기 때문에 크게 문제되지는 않는 것처럼 보일 수 있지만 배열이 더 늘어나거나, 각 배열이 가지는 고유한 변수가 생겨나게 되면 더 복잡해지고, 프로그램의 확장성은 매우 떨어지게 된다.

  

- 이제 이런 상황을 상속으로 개선해보자!

  ```java
  // ImprovedFriendship.java
  
  class Friend {
  	private String name;
  	private String telNum;
  	
  	public Friend(String name, String telNum) {
  		this.name = name;
  		this.telNum = telNum;
  	}
  	
  	public void showInfo() {
  		System.out.print("이름: " + name + " 번호: " + telNum);
  	}
  }
  
  class RealFriends extends Friend {
  	private String major;
  	
  	RealFriends(String name, String telNum, String major) {
  		super(name, telNum);
  		this.major = major;
  	}
  	
  	public void showInfo() {  // 클래스 오버라이딩
  		super.showInfo();     // 얘를 통해 부모 클래스의 메서드를 가지고 이름, 번호 호출
  		System.out.println(" 전공: " + major);   // 고유한 정보 전공 호출
  	}
  }
  
  class FakeFriends extends Friend {
  	private String part;
  	
  	FakeFriends(String name, String telNum, String part) {
  		super(name, telNum);
  		this.part = part;
  	}
  	
  	public void showInfo() {
  		super.showInfo();
  		System.out.println(" 부서: " + part);
  	}
  }
  
  public class ImprovedFriendship {
  
  	public static void main(String[] args) {
  
  		Friend[] fr = new Friend[4];
  		int cnt = 0;
  		
  		fr[cnt++] = new RealFriends("김철수", "010-0000-0000", "경영학과");
  		fr[cnt++] = new RealFriends("이영희", "010-1111-1111", "컴퓨터공학과");
  		fr[cnt++] = new FakeFriends("박지성", "010-2222-2222", "체육학과");
  		fr[cnt++] = new FakeFriends("오미란", "010-3333-3333", "실용음악과");
  		
  		for(int i = 0; i < fr.length; i++) {
  			fr[i].showInfo();
  		}
  	}
  }
  ```

  - 앞선 두 클래스들이 공통적으로 가지는 정보를 꺼내서 하나의 클래스를 만들었다.
  - 그리고 기존의 두 클래스를 부모 클래스를 상속하는 자식 클래스로 만들어줬다!
    - 이렇게 하면 두 클래스가 전부 상속하는 부모 클래스인 Friend를 통해 나머지 두 클래스에 공통적인 규약을 적용할 수 있게 된다.
    - 클래스를 이렇게 디자인하면 관리 대상이 아무리 늘고, 각 대상이 고유한 정보를 얼마를 가지더라도 관리적 측면이나 확장성에서 이점을 유지한다.



# 16-2 Object 클래스, final 선언, 그리고 @Override

> 모든 클래스 위에 Object 클래스가 있다

- 상속을 하지 않으면?

  - 상속하는 클래스가 있다면 문제되지 않지만, 어떤 클래스도 상속하지 않는다면?
  - `java.lang` 패키지 안에 들어있는 **Object 클래스**를 상속하게 된다.
  - `class Yes`는 본질적으로 `class Yes extends Object` 의 정의와 동일하다.
  - 사실 다른 클래스를 상속한 경우에도, 그 상속의 대상이 되는 부모 클래스는 Object 클래스를 상속한다.

  

- 왜일까?
  - 모든 클래스는 Object 클래스를 상속하고 있기 때문!
  - 이를 통해 모든 클래스와 인스턴스에 공통적인 규약을 정의할 수 있기 때문이다.
  - `System.out.println()`가 어떤 인스턴스라도 인자로 전달받아 호출될 수 있던 것도 이 때문!

